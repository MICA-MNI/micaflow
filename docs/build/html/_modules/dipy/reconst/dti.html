

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dipy.reconst.dti &mdash; Micaflow  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=dff4f964" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Micaflow
              <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../getting_started.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting_started.html#basic-usage">Basic Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting_started.html#dependencies">Dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples.html#example-workflows">Example Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples.html#structural-mri-processing">Structural MRI Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples.html#diffusion-mri-processing">Diffusion MRI Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples.html#registration-example">Registration Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts.html">Scripts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../scripts.html#quick-reference">Quick Reference</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Micaflow</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dipy.reconst.dti</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dipy.reconst.dti</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes and functions for fitting tensors.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">opt</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dipy.core.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">vector_norm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dipy.core.gradients</span><span class="w"> </span><span class="kn">import</span> <span class="n">gradient_table</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dipy.core.onetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">auto_attr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dipy.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_sphere</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dipy.reconst.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">ReconstModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dipy.reconst.vec_val_sum</span><span class="w"> </span><span class="kn">import</span> <span class="n">vec_val_vect</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dipy.reconst.weights_method</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">weights_method_nlls_m_est</span><span class="p">,</span>
    <span class="n">weights_method_wls_m_est</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dipy.testing.decorators</span><span class="w"> </span><span class="kn">import</span> <span class="n">warning_for_keywords</span>

<span class="n">MIN_POSITIVE_SIGNAL</span> <span class="o">=</span> <span class="mf">0.0001</span>

<span class="n">ols_resort_msg</span> <span class="o">=</span> <span class="s2">&quot;Resorted to OLS solution in some voxels&quot;</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check evals shape.</span>

<span class="sd">    Helper function to check that the evals provided to functions calculating</span>
<span class="sd">    tensor statistics have the right shape</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor. shape should be (...,3).</span>

<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of the array which contains the 3 eigenvals. Default: -1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor, rolled so that the 3 eigenvals are</span>
<span class="sd">        the last axis.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">evals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Expecting 3 eigenvalues, got </span><span class="si">{</span><span class="n">evals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">evals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">evals</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fractional_anisotropy</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return Fractional anisotropy (FA) of a diffusion tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fa : array</span>
<span class="sd">        Calculated FA. Range is 0 &lt;= FA &lt;= 1.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    FA is calculated using the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        FA = \sqrt{\frac{1}{2}\frac{(\lambda_1-\lambda_2)^2+(\lambda_1-</span>
<span class="sd">                    \lambda_3)^2+(\lambda_2-\lambda_3)^2}{\lambda_1^2+</span>
<span class="sd">                    \lambda_2^2+\lambda_3^2}}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="c1"># Make sure not to get nans</span>
    <span class="n">all_zero</span> <span class="o">=</span> <span class="p">(</span><span class="n">evals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ev1</span><span class="p">,</span> <span class="n">ev2</span><span class="p">,</span> <span class="n">ev3</span> <span class="o">=</span> <span class="n">evals</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="mf">0.5</span>
        <span class="o">*</span> <span class="p">((</span><span class="n">ev1</span> <span class="o">-</span> <span class="n">ev2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ev2</span> <span class="o">-</span> <span class="n">ev3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ev3</span> <span class="o">-</span> <span class="n">ev1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="o">/</span> <span class="p">((</span><span class="n">evals</span> <span class="o">*</span> <span class="n">evals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">all_zero</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">fa</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">geodesic_anisotropy</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Geodesic anisotropy (GA) of a diffusion tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ga : array</span>
<span class="sd">        Calculated GA. In the range 0 to +infinity</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    GA is calculated using the following equation given in</span>
<span class="sd">    :footcite:p:`Batchelor2005`:</span>

<span class="sd">    .. math::</span>

<span class="sd">        GA = \sqrt{\sum_{i=1}^3</span>
<span class="sd">        \log^2{\left ( \lambda_i/&lt;\mathbf{D}&gt; \right )}},</span>
<span class="sd">        \quad \textrm{where} \quad &lt;\mathbf{D}&gt; =</span>
<span class="sd">        (\lambda_1\lambda_2\lambda_3)^{1/3}</span>

<span class="sd">    Note that the notation, $&lt;D&gt;$, is often used as the mean diffusivity (MD)</span>
<span class="sd">    of the diffusion tensor and can lead to confusions in the literature</span>
<span class="sd">    (see :footcite:p:`Batchelor2005` versus :footcite:p:`Correia2011b` versus</span>
<span class="sd">    :footcite:p:`Lee2008` for example). :footcite:p:`Correia2011b` defines</span>
<span class="sd">    geodesic anisotropy (GA) with $&lt;D&gt;$ as the MD in the denominator of the</span>
<span class="sd">    sum. This is wrong. The original paper :footcite:p:`Batchelor2005` defines</span>
<span class="sd">    GA with  $&lt;D&gt; = det(D)^{1/3}$, as the isotropic part of the distance. This</span>
<span class="sd">    might be an explanation for the confusion. The isotropic part of the</span>
<span class="sd">    diffusion tensor in Euclidean space is the MD whereas the isotropic part of</span>
<span class="sd">    the tensor in log-Euclidean space is $det(D)^{1/3}$. The Appendix of</span>
<span class="sd">    :footcite:p:`Batchelor2005` and log-Euclidean derivations from</span>
<span class="sd">    :footcite:p:`Lee2008` are clear on this. Hence, all that to say that</span>
<span class="sd">    $&lt;D&gt; = det(D)^{1/3}$ here for the GA definition and not MD.</span>

<span class="sd">    See also :footcite:p:`Arsigny2006`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ev1</span><span class="p">,</span> <span class="n">ev2</span><span class="p">,</span> <span class="n">ev3</span> <span class="o">=</span> <span class="n">evals</span>

    <span class="n">log1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ev1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">log2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ev1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">log3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ev1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ev1</span><span class="p">)</span>

    <span class="c1"># this is the definition in :footcite:p:`Batchelor2005`</span>
    <span class="n">detD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">ev1</span> <span class="o">*</span> <span class="n">ev2</span> <span class="o">*</span> <span class="n">ev3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
    <span class="n">log1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ev1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">detD</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">log2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ev2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">detD</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">log3</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ev3</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">detD</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

    <span class="n">ga</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">log1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">log2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">log3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ga</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">mean_diffusivity</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mean Diffusivity (MD) of a diffusion tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    md : array</span>
<span class="sd">        Calculated MD.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    MD is calculated with the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        MD = \frac{\lambda_1 + \lambda_2 + \lambda_3}{3}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">evals</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">axial_diffusivity</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Axial Diffusivity (AD) of a diffusion tensor.</span>
<span class="sd">    Also called parallel diffusivity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor, must be sorted in descending order</span>
<span class="sd">        along `axis`.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ad : array</span>
<span class="sd">        Calculated AD.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    AD is calculated with the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        AD = \lambda_1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ev1</span><span class="p">,</span> <span class="n">ev2</span><span class="p">,</span> <span class="n">ev3</span> <span class="o">=</span> <span class="n">evals</span>
    <span class="k">return</span> <span class="n">ev1</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">radial_diffusivity</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Radial Diffusivity (RD) of a diffusion tensor.</span>
<span class="sd">    Also called perpendicular diffusivity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor, must be sorted in descending order</span>
<span class="sd">        along `axis`.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rd : array</span>
<span class="sd">        Calculated RD.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    RD is calculated with the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        RD = \frac{\lambda_2 + \lambda_3}{2}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">evals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trace of a diffusion tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trace : array</span>
<span class="sd">        Calculated trace of the diffusion tensor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Trace is calculated with the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        Trace = \lambda_1 + \lambda_2 + \lambda_3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">evals</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">color_fa</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">evecs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Color fractional anisotropy of diffusion tensor</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fa : array-like</span>
<span class="sd">        Array of the fractional anisotropy (can be 1D, 2D or 3D)</span>

<span class="sd">    evecs : array-like</span>
<span class="sd">        eigen vectors from the tensor model</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rgb : Array with 3 channels for each color as the last dimension.</span>
<span class="sd">        Colormap of the FA with red for the x value, y for the green</span>
<span class="sd">        value and z for the blue value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    It is computed from the clipped FA between 0 and 1 using the following</span>
<span class="sd">    formula</span>

<span class="sd">    .. math::</span>

<span class="sd">        rgb = abs(max(\vec{e})) \times fa</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">evecs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong number of dimensions for evecs&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evecs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>


<span class="c1"># The following are used to calculate the tensor mode:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">determinant</span><span class="p">(</span><span class="n">q_form</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The determinant of a tensor, given in quadratic form</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q_form : ndarray</span>
<span class="sd">        The quadratic form of a tensor, or an array with quadratic forms of</span>
<span class="sd">        tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    det : array</span>
<span class="sd">        The determinant of the tensor in each spatial coordinate</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Following the conventions used here:</span>
    <span class="c1"># https://en.wikipedia.org/wiki/Determinant</span>
    <span class="n">aei</span> <span class="o">=</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">bfg</span> <span class="o">=</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">cdh</span> <span class="o">=</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">ceg</span> <span class="o">=</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">bdi</span> <span class="o">=</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">afh</span> <span class="o">=</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">aei</span> <span class="o">+</span> <span class="n">bfg</span> <span class="o">+</span> <span class="n">cdh</span> <span class="o">-</span> <span class="n">ceg</span> <span class="o">-</span> <span class="n">bdi</span> <span class="o">-</span> <span class="n">afh</span>


<span class="k">def</span><span class="w"> </span><span class="nf">isotropic</span><span class="p">(</span><span class="n">q_form</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the isotropic part of the tensor.</span>

<span class="sd">    See :footcite:p:`Ennis2006` for further details about the method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q_form : ndarray</span>
<span class="sd">        The quadratic form of a tensor, or an array with quadratic forms of</span>
<span class="sd">        tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A_hat: ndarray</span>
<span class="sd">        The isotropic part of the tensor in each spatial coordinate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The isotropic part of a tensor is defined as (equations 3-5 of</span>
<span class="sd">    :footcite:p:`Ennis2006`):</span>

<span class="sd">    .. math::</span>
<span class="sd">        \bar{A} = \frac{1}{2} tr(A) I</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tr_A</span> <span class="o">=</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">q_form</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">my_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">tr_AI</span> <span class="o">=</span> <span class="n">tr_A</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tr_A</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">my_I</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">tr_AI</span>


<span class="k">def</span><span class="w"> </span><span class="nf">deviatoric</span><span class="p">(</span><span class="n">q_form</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the deviatoric (anisotropic) part of the tensor.</span>

<span class="sd">    See :footcite:p:`Ennis2006` for further details about the method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q_form : ndarray</span>
<span class="sd">        The quadratic form of a tensor, or an array with quadratic forms of</span>
<span class="sd">        tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A_squiggle : ndarray</span>
<span class="sd">        The deviatoric part of the tensor in each spatial coordinate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The deviatoric part of the tensor is defined as (equations 3-5 in</span>
<span class="sd">    :footcite:p:`Ennis2006`):</span>

<span class="sd">    .. math::</span>
<span class="sd">        \widetilde{A} = A - \bar{A}</span>

<span class="sd">    Where $A$ is the tensor quadratic form and $\bar{A}$ is the anisotropic</span>
<span class="sd">    part of the tensor.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_squiggle</span> <span class="o">=</span> <span class="n">q_form</span> <span class="o">-</span> <span class="n">isotropic</span><span class="p">(</span><span class="n">q_form</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A_squiggle</span>


<span class="k">def</span><span class="w"> </span><span class="nf">norm</span><span class="p">(</span><span class="n">q_form</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Frobenius norm of a tensor quadratic form</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q_form: ndarray</span>
<span class="sd">        The quadratic form of a tensor, or an array with quadratic forms of</span>
<span class="sd">        tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    norm : ndarray</span>
<span class="sd">        The Frobenius norm of the 3,3 tensor q_form in each spatial</span>
<span class="sd">        coordinate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Frobenius norm is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        ||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    np.linalg.norm</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_form</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">mode</span><span class="p">(</span><span class="n">q_form</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mode (MO) of a diffusion tensor.</span>

<span class="sd">    See :footcite:p:`Ennis2006` for further details about the method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q_form : ndarray</span>
<span class="sd">        The quadratic form of a tensor, or an array with quadratic forms of</span>
<span class="sd">        tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mode : array</span>
<span class="sd">        Calculated tensor mode in each spatial coordinate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Mode ranges between -1 (planar anisotropy) and +1 (linear anisotropy)</span>
<span class="sd">    with 0 representing isotropy. Mode is calculated with the following</span>
<span class="sd">    equation (equation 9 in :footcite:p:`Ennis2006`):</span>

<span class="sd">    .. math::</span>

<span class="sd">        Mode = 3*\sqrt{6}*det(\widetilde{A}/norm(\widetilde{A}))</span>

<span class="sd">    Where $\widetilde{A}$ is the deviatoric part of the tensor quadratic form.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_squiggle</span> <span class="o">=</span> <span class="n">deviatoric</span><span class="p">(</span><span class="n">q_form</span><span class="p">)</span>
    <span class="n">A_s_norm</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">A_squiggle</span><span class="p">)</span>

    <span class="n">mode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A_s_norm</span><span class="p">)</span>
    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">A_s_norm</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">A_squiggle_nonzero</span> <span class="o">=</span> <span class="n">A_squiggle</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
    <span class="c1"># Add two dims for the (3,3), so that it can broadcast on A_squiggle</span>
    <span class="n">A_s_norm_nonzero</span> <span class="o">=</span> <span class="n">A_s_norm</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">mode_nonzero</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="n">determinant</span><span class="p">(</span><span class="n">A_squiggle_nonzero</span> <span class="o">/</span> <span class="n">A_s_norm_nonzero</span><span class="p">)</span>
    <span class="n">mode</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode_nonzero</span>

    <span class="k">return</span> <span class="n">mode</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">linearity</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The linearity of the tensor.</span>

<span class="sd">    See :footcite:p:`Westin1997` for further details about the method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    linearity : array</span>
<span class="sd">        Calculated linearity of the diffusion tensor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Linearity is calculated with the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        Linearity = \frac{\lambda_1-\lambda_2}{\lambda_1+\lambda_2+\lambda_3}</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ev1</span><span class="p">,</span> <span class="n">ev2</span><span class="p">,</span> <span class="n">ev3</span> <span class="o">=</span> <span class="n">evals</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ev1</span> <span class="o">-</span> <span class="n">ev2</span><span class="p">)</span> <span class="o">/</span> <span class="n">evals</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">planarity</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The planarity of the tensor.</span>

<span class="sd">    See :footcite:p:`Westin1997` for further details about the method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    linearity : array</span>
<span class="sd">        Calculated linearity of the diffusion tensor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Planarity is calculated with the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        Planarity =</span>
<span class="sd">        \frac{2 (\lambda_2-\lambda_3)}{\lambda_1+\lambda_2+\lambda_3}</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ev1</span><span class="p">,</span> <span class="n">ev2</span><span class="p">,</span> <span class="n">ev3</span> <span class="o">=</span> <span class="n">evals</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">ev2</span> <span class="o">-</span> <span class="n">ev3</span><span class="p">)</span> <span class="o">/</span> <span class="n">evals</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sphericity</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The sphericity of the tensor.</span>

<span class="sd">    See :footcite:p:`Westin1997` for further details about the method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evals : array-like</span>
<span class="sd">        Eigenvalues of a diffusion tensor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `evals` which contains 3 eigenvalues.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sphericity : array</span>
<span class="sd">        Calculated sphericity of the diffusion tensor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Sphericity is calculated with the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        Sphericity = \frac{3 \lambda_3)}{\lambda_1+\lambda_2+\lambda_3}</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_roll_evals</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ev1</span><span class="p">,</span> <span class="n">ev2</span><span class="p">,</span> <span class="n">ev3</span> <span class="o">=</span> <span class="n">evals</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">ev3</span><span class="p">)</span> <span class="o">/</span> <span class="n">evals</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">apparent_diffusion_coef</span><span class="p">(</span><span class="n">q_form</span><span class="p">,</span> <span class="n">sphere</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the apparent diffusion coefficient (ADC) in each direction of a</span>
<span class="sd">    sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q_form : ndarray</span>
<span class="sd">        The quadratic form of a tensor, or an array with quadratic forms of</span>
<span class="sd">        tensors. Should be of shape (..., 3, 3)</span>

<span class="sd">    sphere : a Sphere class instance</span>
<span class="sd">        The ADC will be calculated for each of the vertices in the sphere</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The calculation of ADC, relies on the following relationship:</span>

<span class="sd">    .. math::</span>

<span class="sd">        ADC = \vec{b} Q \vec{b}^T</span>

<span class="sd">    Where Q is the quadratic form of the tensor.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bvecs</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">bvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">gtab</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="o">=</span><span class="n">bvecs</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lower_triangular</span><span class="p">(</span><span class="n">q_form</span><span class="p">),</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">tensor_prediction</span><span class="p">(</span><span class="n">dti_params</span><span class="p">,</span> <span class="n">gtab</span><span class="p">,</span> <span class="n">S0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict a signal given tensor parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dti_params : ndarray</span>
<span class="sd">        Tensor parameters. The last dimension should have 12 tensor</span>
<span class="sd">        parameters: 3 eigenvalues, followed by the 3 corresponding</span>
<span class="sd">        eigenvectors.</span>

<span class="sd">    gtab : a GradientTable class instance</span>
<span class="sd">        The gradient table for this prediction</span>

<span class="sd">    S0 : float or ndarray</span>
<span class="sd">        The non diffusion-weighted signal in every voxel, or across all</span>
<span class="sd">        voxels. Default: 1</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The predicted signal is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        S(\theta, b) = S_0 * e^{-b ADC}</span>

<span class="sd">    where $ADC = \theta Q \theta^T$, $\theta$ is a unit vector pointing at any</span>
<span class="sd">    direction on the sphere for which a signal is to be predicted, $b$ is the b</span>
<span class="sd">    value provided in the GradientTable input for that direction, $Q$ is the</span>
<span class="sd">    quadratic form of the tensor determined by the input parameters.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">dti_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">evecs</span> <span class="o">=</span> <span class="n">dti_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dti_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">qform</span> <span class="o">=</span> <span class="n">vec_val_vect</span><span class="p">(</span><span class="n">evecs</span><span class="p">,</span> <span class="n">evals</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span>
    <span class="n">lower_tri</span> <span class="o">=</span> <span class="n">lower_triangular</span><span class="p">(</span><span class="n">qform</span><span class="p">,</span> <span class="n">b0</span><span class="o">=</span><span class="n">S0</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">qform</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lower_tri</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>


<div class="viewcode-block" id="TensorModel">
<a class="viewcode-back" href="../../../scripts/compute_fa_md.html#micaflow.scripts.compute_fa_md.TensorModel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TensorModel</span><span class="p">(</span><span class="n">ReconstModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Diffusion Tensor&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gtab</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">fit_method</span><span class="o">=</span><span class="s2">&quot;WLS&quot;</span><span class="p">,</span> <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A Diffusion Tensor Model.</span>

<span class="sd">        See :footcite:p:`Basser1994b` and :footcite:p:`Basser1996` for further</span>
<span class="sd">        details about the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gtab : GradientTable class instance</span>
<span class="sd">            Gradient table.</span>
<span class="sd">        fit_method : str or callable, optional</span>
<span class="sd">            str can be one of the following:</span>

<span class="sd">            &#39;WLS&#39; for weighted least squares</span>
<span class="sd">                :func:`dti.wls_fit_tensor`</span>
<span class="sd">            &#39;LS&#39; or &#39;OLS&#39; for ordinary least squares</span>
<span class="sd">                :func:`dti.ols_fit_tensor`</span>
<span class="sd">            &#39;NLLS&#39; for non-linear least-squares</span>
<span class="sd">                :func:`dti.nlls_fit_tensor`</span>
<span class="sd">            &#39;RT&#39; or &#39;restore&#39; or &#39;RESTORE&#39; for RESTORE robust tensor</span>
<span class="sd">                fitting :footcite:p:`Chang2005`</span>
<span class="sd">                :func:`dti.restore_fit_tensor`</span>

<span class="sd">            callable has to have the signature:</span>
<span class="sd">              ``fit_method(design_matrix, data, *args, **kwargs)``</span>

<span class="sd">        return_S0_hat : bool, optional</span>
<span class="sd">            Boolean to return (True) or not (False) the S0 values for the fit.</span>

<span class="sd">        args, kwargs : arguments and key-word arguments passed to the</span>
<span class="sd">           fit_method. See :func:`dti.wls_fit_tensor`,</span>
<span class="sd">           :func:`dti.ols_fit_tensor` for details</span>

<span class="sd">        min_signal : float, optional</span>
<span class="sd">            The minimum signal value. Needs to be a strictly positive</span>
<span class="sd">            number. Default: minimal signal in the data provided to `fit`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In order to increase speed of processing, tensor fitting is done</span>
<span class="sd">        simultaneously over many voxels. Many fit_methods use the &#39;step&#39;</span>
<span class="sd">        parameter to set the number of voxels that will be fit at once in each</span>
<span class="sd">        iteration. This is the chunk size as a number of voxels. A larger step</span>
<span class="sd">        value should speed things up, but it will also take up more memory. It</span>
<span class="sd">        is advisable to keep an eye on memory consumption as this value is</span>
<span class="sd">        increased.</span>

<span class="sd">        E.g., in :func:`iter_fit_tensor` we have a default step value of</span>
<span class="sd">        1e4</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. footbibliography::</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ReconstModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gtab</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">fit_method</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fit_method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;NLS&quot;</span><span class="p">,</span> <span class="s2">&quot;NLLS&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;step&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;The &#39;step&#39; parameter can not be used in the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fit_method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> method. It will be ignored.&quot;</span><span class="p">,</span>
                        <span class="ne">UserWarning</span><span class="p">,</span>
                        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">fit_method</span> <span class="o">=</span> <span class="n">common_fit_methods</span><span class="p">[</span><span class="n">fit_method</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">e_s</span> <span class="o">=</span> <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fit_method</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot; is not a known fit &#39;</span>
                <span class="n">e_s</span> <span class="o">+=</span> <span class="s2">&quot;method, the fit method should either be a &quot;</span>
                <span class="n">e_s</span> <span class="o">+=</span> <span class="s2">&quot;function or one of the common fit methods&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">e_s</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span> <span class="n">fit_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_S0_hat</span> <span class="o">=</span> <span class="n">return_S0_hat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_matrix</span> <span class="o">=</span> <span class="n">design_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gtab</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;min_signal&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_signal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_signal</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e_s</span> <span class="o">=</span> <span class="s2">&quot;The `min_signal` key-word argument needs to be strictly&quot;</span>
            <span class="n">e_s</span> <span class="o">+=</span> <span class="s2">&quot; positive.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">e_s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="TensorModel.fit">
<a class="viewcode-back" href="../../../scripts/compute_fa_md.html#micaflow.scripts.compute_fa_md.TensorModel.fit">[docs]</a>
    <span class="nd">@warning_for_keywords</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit method of the DTI model class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array</span>
<span class="sd">            The measured signal from one voxel.</span>

<span class="sd">        mask : array, optional</span>
<span class="sd">            A boolean array used to mark the coordinates in the data that</span>
<span class="sd">            should be analyzed that has the shape data.shape[:-1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S0_params</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">img_shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check for valid shape of the mask</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">img_shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mask is not the same shape as data.&quot;</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">data_in_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_signal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_signal</span> <span class="o">=</span> <span class="n">MIN_POSITIVE_SIGNAL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_signal</span>

        <span class="n">data_in_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data_in_mask</span><span class="p">,</span> <span class="n">min_signal</span><span class="p">)</span>

        <span class="n">params_in_mask</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">design_matrix</span><span class="p">,</span>
            <span class="n">data_in_mask</span><span class="p">,</span>
            <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span>
            <span class="n">return_S0_hat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_S0_hat</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_S0_hat</span><span class="p">:</span>
            <span class="n">params_in_mask</span><span class="p">,</span> <span class="n">model_S0</span> <span class="o">=</span> <span class="n">params_in_mask</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
            <span class="n">dti_params</span> <span class="o">=</span> <span class="n">params_in_mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_S0_hat</span><span class="p">:</span>
                <span class="n">S0_params</span> <span class="o">=</span> <span class="n">model_S0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">extra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dti_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">12</span><span class="p">,))</span>
            <span class="n">dti_params</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">params_in_mask</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_S0_hat</span><span class="p">:</span>
                <span class="n">S0_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">S0_params</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_S0</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">S0_params</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_S0</span>
            <span class="k">if</span> <span class="n">extra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">TensorFit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dti_params</span><span class="p">,</span> <span class="n">model_S0</span><span class="o">=</span><span class="n">S0_params</span><span class="p">)</span></div>


<div class="viewcode-block" id="TensorModel.predict">
<a class="viewcode-back" href="../../../scripts/compute_fa_md.html#micaflow.scripts.compute_fa_md.TensorModel.predict">[docs]</a>
    <span class="nd">@warning_for_keywords</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dti_params</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">S0</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict a signal for this TensorModel class instance given parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dti_params : ndarray</span>
<span class="sd">            The last dimension should have 12 tensor parameters: 3</span>
<span class="sd">            eigenvalues, followed by the 3 eigenvectors</span>

<span class="sd">        S0 : float or ndarray, optional</span>
<span class="sd">            The non diffusion-weighted signal in every voxel, or across all</span>
<span class="sd">            voxels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">tensor_prediction</span><span class="p">(</span><span class="n">dti_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gtab</span><span class="p">,</span> <span class="n">S0</span><span class="p">)</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">TensorFit</span><span class="p">:</span>
    <span class="nd">@warning_for_keywords</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">model_params</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">model_S0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a TensorFit class instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_params</span> <span class="o">=</span> <span class="n">model_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_S0</span> <span class="o">=</span> <span class="n">model_S0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">model_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_params</span>
        <span class="n">model_S0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_S0</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">model_params</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">model_params</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;IndexError: invalid index&quot;</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">model_S0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_S0</span> <span class="o">=</span> <span class="n">model_S0</span><span class="p">[</span><span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">model_params</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">model_S0</span><span class="o">=</span><span class="n">model_S0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">S0_hat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_S0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">directions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For tracking - return the primary direction in each voxel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evecs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">evals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the eigenvalues of the tensor as an array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">evecs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the eigenvectors of the tensor as an array, columnwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">evecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">quadratic_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the 3x3 diffusion tensor for each voxel&quot;&quot;&quot;</span>
        <span class="c1"># do `evecs * evals * evecs.T` where * is matrix multiply</span>
        <span class="c1"># einsum does this with:</span>
        <span class="c1"># np.einsum(&#39;...ij,...j,...kj-&gt;...ik&#39;, evecs, evals, evecs)</span>
        <span class="k">return</span> <span class="n">vec_val_vect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evecs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="nd">@warning_for_keywords</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lower_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">b0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lower_triangular</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadratic_form</span><span class="p">,</span> <span class="n">b0</span><span class="o">=</span><span class="n">b0</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fa</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fractional anisotropy (FA) calculated from cached eigenvalues.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fractional_anisotropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">color_fa</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Color fractional anisotropy of diffusion tensor&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">color_fa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evecs</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ga</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Geodesic anisotropy (GA) calculated from cached eigenvalues.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">geodesic_anisotropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tensor mode calculated from cached eigenvalues.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadratic_form</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">md</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mean diffusivity (MD) calculated from cached eigenvalues.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        md : array (V, 1)</span>
<span class="sd">            Calculated MD.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        MD is calculated with the following equation:</span>

<span class="sd">        .. math::</span>

<span class="sd">            MD = \frac{\lambda_1+\lambda_2+\lambda_3}{3}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">/</span> <span class="mf">3.0</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Radial diffusivity (RD) calculated from cached eigenvalues.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rd : array (V, 1)</span>
<span class="sd">            Calculated RD.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        RD is calculated with the following equation:</span>

<span class="sd">        .. math::</span>

<span class="sd">          RD = \frac{\lambda_2 + \lambda_3}{2}</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">radial_diffusivity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Axial diffusivity (AD) calculated from cached eigenvalues.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ad : array (V, 1)</span>
<span class="sd">            Calculated AD.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        AD is calculated with the following equation:</span>

<span class="sd">        .. math::</span>

<span class="sd">          AD = \lambda_1</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">axial_diffusivity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trace of the tensor calculated from cached eigenvalues.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trace : array (V, 1)</span>
<span class="sd">            Calculated trace.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The trace is calculated with the following equation:</span>

<span class="sd">        .. math::</span>

<span class="sd">          trace = \lambda_1 + \lambda_2 + \lambda_3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">planarity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sphericity : array</span>
<span class="sd">            Calculated sphericity of the diffusion tensor</span>
<span class="sd">            :footcite:p:`Westin1997`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Sphericity is calculated with the following equation:</span>

<span class="sd">        .. math::</span>

<span class="sd">            Sphericity =</span>
<span class="sd">            \frac{2 (\lambda_2 - \lambda_3)}{\lambda_1+\lambda_2+\lambda_3}</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. footbibliography::</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">planarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">linearity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linearity : array</span>
<span class="sd">            Calculated linearity of the diffusion tensor</span>
<span class="sd">            :footcite:p:`Westin1997`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Linearity is calculated with the following equation:</span>

<span class="sd">        .. math::</span>

<span class="sd">            Linearity =</span>
<span class="sd">            \frac{\lambda_1-\lambda_2}{\lambda_1+\lambda_2+\lambda_3}</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. footbibliography::</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">linearity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="nd">@auto_attr</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sphericity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sphericity : array</span>
<span class="sd">            Calculated sphericity of the diffusion tensor</span>
<span class="sd">            :footcite:p:`Westin1997`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Sphericity is calculated with the following equation:</span>

<span class="sd">        .. math::</span>

<span class="sd">            Sphericity = \frac{3 \lambda_3}{\lambda_1+\lambda_2+\lambda_3}</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. footbibliography::</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sphericity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">odf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sphere</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The diffusion orientation distribution function (dODF). This is an</span>
<span class="sd">        estimate of the diffusion distance in each direction</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sphere : Sphere class instance.</span>
<span class="sd">            The dODF is calculated in the vertices of this input.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        odf : ndarray</span>
<span class="sd">            The diffusion distance in every direction of the sphere in every</span>
<span class="sd">            voxel in the input data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is based on equation 3 in :footcite:p:`Aganj2010`. To re-derive it</span>
<span class="sd">        from scratch, follow steps in :footcite:p:`Descoteaux2008b`, Section 7.9</span>
<span class="sd">        Equation 7.24 but with an $r^2$ term in the integral.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. footbibliography::</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">odf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">evals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evecs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span>
            <span class="n">evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evecs</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">evecs</span><span class="p">)</span>
        <span class="n">projection</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">vector_norm</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">lower</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">odf</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">odf</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">odf</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">adc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sphere</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the apparent diffusion coefficient (ADC) in each direction on</span>
<span class="sd">        the sphere for each voxel in the data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sphere : Sphere class instance</span>
<span class="sd">            Sphere providing sample directions to compute the apparent diffusion</span>
<span class="sd">            coefficient.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adc : ndarray</span>
<span class="sd">           The estimates of the apparent diffusion coefficient in every</span>
<span class="sd">           direction on the input sphere</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The calculation of ADC, relies on the following relationship:</span>

<span class="sd">        .. math::</span>

<span class="sd">            ADC = \vec{b} Q \vec{b}^T</span>

<span class="sd">        Where Q is the quadratic form of the tensor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">apparent_diffusion_coef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadratic_form</span><span class="p">,</span> <span class="n">sphere</span><span class="p">)</span>

    <span class="nd">@warning_for_keywords</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gtab</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">S0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a model fit, predict the signal on the vertices of a sphere</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gtab : a GradientTable class instance</span>
<span class="sd">            This encodes the directions for which a prediction is made</span>

<span class="sd">        S0 : float array, optional</span>
<span class="sd">           The mean non-diffusion weighted signal in each voxel. Default:</span>
<span class="sd">           The fitted S0 value in all voxels if it was fitted. Otherwise 1 in</span>
<span class="sd">           all voxels.</span>

<span class="sd">        step : int, optional</span>
<span class="sd">            The chunk size as a number of voxels. Optional parameter with</span>
<span class="sd">            default value 10,000.</span>

<span class="sd">            In order to increase speed of processing, tensor fitting is done</span>
<span class="sd">            simultaneously over many voxels. This parameter sets the number of</span>
<span class="sd">            voxels that will be fit at once in each iteration. A larger step</span>
<span class="sd">            value should speed things up, but it will also take up more memory.</span>
<span class="sd">            It is advisable to keep an eye on memory consumption as this value</span>
<span class="sd">            is increased.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The predicted signal is given by:</span>

<span class="sd">        .. math::</span>

<span class="sd">            S(\theta, b) = S_0 * e^{-b ADC}</span>

<span class="sd">        Where:</span>
<span class="sd">        .. math::</span>

<span class="sd">            ADC = \theta Q \theta^T</span>

<span class="sd">        $\theta$ is a unit vector pointing at any direction on the sphere for</span>
<span class="sd">        which a signal is to be predicted and $b$ is the b value provided in</span>
<span class="sd">        the GradientTable input for that direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">S0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">S0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_S0</span>
            <span class="k">if</span> <span class="n">S0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if we didn&#39;t input or estimate S0 just use 1</span>
                <span class="n">S0</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tensor_prediction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">12</span><span class="p">],</span> <span class="n">gtab</span><span class="p">,</span> <span class="n">S0</span><span class="o">=</span><span class="n">S0</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_params</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">S0</span> <span class="o">=</span> <span class="n">S0</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">this_S0</span> <span class="o">=</span> <span class="n">S0</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">this_S0</span> <span class="o">=</span> <span class="n">S0</span>
            <span class="n">predict</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor_prediction</span><span class="p">(</span>
                <span class="n">params</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">],</span> <span class="n">gtab</span><span class="p">,</span> <span class="n">S0</span><span class="o">=</span><span class="n">this_S0</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">predict</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">gtab</span><span class="o">.</span><span class="n">bvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">iter_fit_tensor</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">1e4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrap a fit_tensor func and iterate over chunks of data with given length</span>

<span class="sd">    Splits data into a number of chunks of specified size and iterates the</span>
<span class="sd">    decorated fit_tensor function over them. This is useful to counteract the</span>
<span class="sd">    temporary but significant memory usage increase in fit_tensor functions</span>
<span class="sd">    that use vectorized operations and need to store large temporary arrays for</span>
<span class="sd">    their vectorized operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    step : int, optional</span>
<span class="sd">        The chunk size as a number of voxels. Optional parameter with default</span>
<span class="sd">        value 10,000.</span>

<span class="sd">        In order to increase speed of processing, tensor fitting is done</span>
<span class="sd">        simultaneously over many voxels. This parameter sets the number of</span>
<span class="sd">        voxels that will be fit at once in each iteration. A larger step value</span>
<span class="sd">        should speed things up, but it will also take up more memory. It is</span>
<span class="sd">        advisable to keep an eye on memory consumption as this value is</span>
<span class="sd">        increased.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">iter_decorator</span><span class="p">(</span><span class="n">fit_tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Actual iter decorator returned by iter_fit_tensor dec factory</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fit_tensor : callable</span>
<span class="sd">            A tensor fitting callable (most likely a function). The callable</span>
<span class="sd">            has to have the signature:</span>
<span class="sd">              ``fit_method(design_matrix, data, *args, **kwargs)``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fit_tensor</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">wrapped_fit_tensor</span><span class="p">(</span>
            <span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Iterate fit_tensor function over the data chunks</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            design_matrix : array (g, 7)</span>
<span class="sd">                Design matrix holding the covariants used to solve for the</span>
<span class="sd">                regression coefficients.</span>
<span class="sd">            data : array ([X, Y, Z, ...], g)</span>
<span class="sd">                Data or response variables holding the data. Note that the last</span>
<span class="sd">                dimension should contain the data. It makes no copies of data.</span>
<span class="sd">            return_S0_hat : bool, optional</span>
<span class="sd">                Boolean to return (True) or not (False) the S0 values for the</span>
<span class="sd">                fit.</span>
<span class="sd">            step : int, optional</span>
<span class="sd">                The chunk size as a number of voxels. Overrides `step` value</span>
<span class="sd">                of `iter_fit_tensor`.</span>
<span class="sd">            args : {list,tuple}</span>
<span class="sd">                Any extra optional positional arguments passed to `fit_tensor`.</span>
<span class="sd">            kwargs : dict</span>
<span class="sd">                Any extra optional keyword arguments passed to `fit_tensor`.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="ow">or</span> <span class="n">size</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;weights&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fit_tensor</span><span class="p">(</span>
                    <span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">return_S0_hat</span><span class="o">=</span><span class="n">return_S0_hat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">design_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">22</span><span class="p">:</span>  <span class="c1"># DKI</span>
                <span class="n">sz</span> <span class="o">=</span> <span class="mi">22</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># DTI</span>
                <span class="n">sz</span> <span class="o">=</span> <span class="mi">7</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_lower_triangular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="mi">12</span>
            <span class="n">dtiparams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">sz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
                <span class="n">S0params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">extra</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">dtiparams</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">],</span> <span class="n">S0params</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">]),</span> <span class="n">extra_i</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">fit_tensor</span><span class="p">(</span>
                            <span class="n">design_matrix</span><span class="p">,</span>
                            <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">],</span>
                            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                            <span class="n">return_S0_hat</span><span class="o">=</span><span class="n">return_S0_hat</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtiparams</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">],</span> <span class="n">extra_i</span> <span class="o">=</span> <span class="n">fit_tensor</span><span class="p">(</span>
                        <span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">extra_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra_i</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                        <span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra_i</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">extra</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra</span><span class="p">:</span>
                    <span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

            <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">dtiparams</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">sz</span><span class="p">,)),</span>
                    <span class="n">S0params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
                <span class="p">),</span> <span class="n">extra</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dtiparams</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">sz</span><span class="p">,)),</span> <span class="n">extra</span>

        <span class="k">return</span> <span class="n">wrapped_fit_tensor</span>

    <span class="k">return</span> <span class="n">iter_decorator</span>


<span class="nd">@iter_fit_tensor</span><span class="p">()</span>
<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">wls_fit_tensor</span><span class="p">(</span>
    <span class="n">design_matrix</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_leverages</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes weighted least squares (WLS) fit to calculate self-diffusion</span>
<span class="sd">    tensor using a linear regression model.</span>

<span class="sd">    See :footcite:p:`Chung2006` for further details about the method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    design_matrix : array (g, 7)</span>
<span class="sd">        Design matrix holding the covariants used to solve for the regression</span>
<span class="sd">        coefficients.</span>
<span class="sd">    data : array ([X, Y, Z, ...], g)</span>
<span class="sd">        Data or response variables holding the data. Note that the last</span>
<span class="sd">        dimension should contain the data. It makes no copies of data.</span>
<span class="sd">    weights : array ([X, Y, Z, ...], g), optional</span>
<span class="sd">        Weights to apply for fitting. These weights must correspond to the</span>
<span class="sd">        squared residuals such that $S = \sum_i w_i r_i^2$.</span>
<span class="sd">        If not provided, weights are estimated as the squared predicted signal</span>
<span class="sd">        from an initial OLS fit :footcite:p:`Chung2006`.</span>
<span class="sd">    return_S0_hat : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the S0 values for the fit.</span>
<span class="sd">    return_lower_triangular : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the coefficients of the fit.</span>
<span class="sd">    return_leverages : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the fitting leverages.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eigvals : array (..., 3)</span>
<span class="sd">        Eigenvalues from eigen decomposition of the tensor.</span>
<span class="sd">    eigvecs : array (..., 3, 3)</span>
<span class="sd">        Associated eigenvectors from eigen decomposition of the tensor.</span>
<span class="sd">        Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with</span>
<span class="sd">        eigvals[j])</span>
<span class="sd">    leverages : array (g)</span>
<span class="sd">        Leverages of the fitting problem (if return_leverages is True)</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    decompose_tensor</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In Chung, et al. 2006, the regression of the WLS fit needed an unbiased</span>
<span class="sd">    preliminary estimate of the weights and therefore the ordinary least</span>
<span class="sd">    squares (OLS) estimates were used. A &quot;two pass&quot; method was implemented:</span>

<span class="sd">        1. calculate OLS estimates of the data</span>
<span class="sd">        2. apply the OLS estimates as weights to the WLS fit of the data</span>

<span class="sd">    This ensured heteroscedasticity could be properly modeled for various</span>
<span class="sd">    types of bootstrap resampling (namely residual bootstrap).</span>

<span class="sd">    .. math::</span>

<span class="sd">        y = \mathrm{data} \\</span>
<span class="sd">        X = \mathrm{design matrix} \\</span>
<span class="sd">        \hat{\beta}_\mathrm{WLS} =</span>
<span class="sd">        \mathrm{desired regression coefficients (e.g. tensor)}\\</span>
<span class="sd">        \\</span>
<span class="sd">        \hat{\beta}_\mathrm{WLS} = (X^T W X)^{-1} X^T W y \\</span>
<span class="sd">        \\</span>
<span class="sd">        W = \mathrm{diag}((X \hat{\beta}_\mathrm{OLS})^2),</span>
<span class="sd">        \mathrm{where} \hat{\beta}_\mathrm{OLS} = (X^T X)^{-1} X^T y</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">log_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># calculate weights</span>
        <span class="n">fit_result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ols_fit_tensor</span><span class="p">(</span>
            <span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">fit_result</span> <span class="o">@</span> <span class="n">design_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># the weighted problem design_matrix * w is much larger (differs per voxel)</span>
    <span class="k">if</span> <span class="n">return_leverages</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fit_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;...ij,...j&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">design_matrix</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">w</span> <span class="o">*</span> <span class="n">log_s</span>
        <span class="p">)</span>
        <span class="n">leverages</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;...ij,...j-&gt;...ij&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">design_matrix</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">w</span>
        <span class="p">)</span>
        <span class="n">fit_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ij,...j&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">log_s</span><span class="p">)</span>
        <span class="n">leverages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,...ji-&gt;...i&quot;</span><span class="p">,</span> <span class="n">design_matrix</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">leverages</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">leverages</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;leverages&quot;</span><span class="p">:</span> <span class="n">leverages</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">return_lower_triangular</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fit_result</span><span class="p">,</span> <span class="n">leverages</span>

    <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">eig_from_lo_tri</span><span class="p">(</span><span class="n">fit_result</span><span class="p">,</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">tol</span> <span class="o">/</span> <span class="o">-</span><span class="n">design_matrix</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fit_result</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">),</span> <span class="n">leverages</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eig_from_lo_tri</span><span class="p">(</span>
            <span class="n">fit_result</span><span class="p">,</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">tol</span> <span class="o">/</span> <span class="o">-</span><span class="n">design_matrix</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="p">),</span> <span class="n">leverages</span>


<span class="nd">@iter_fit_tensor</span><span class="p">()</span>
<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ols_fit_tensor</span><span class="p">(</span>
    <span class="n">design_matrix</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_leverages</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes ordinary least squares (OLS) fit to calculate self-diffusion</span>
<span class="sd">    tensor using a linear regression model.</span>

<span class="sd">    See :footcite:p:`Chung2006` for further details about the method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    design_matrix : array (g, 7)</span>
<span class="sd">        Design matrix holding the covariants used to solve for the regression</span>
<span class="sd">        coefficients.</span>
<span class="sd">    data : array ([X, Y, Z, ...], g)</span>
<span class="sd">        Data or response variables holding the data. Note that the last</span>
<span class="sd">        dimension should contain the data. It makes no copies of data.</span>
<span class="sd">    return_S0_hat : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the S0 values for the fit.</span>
<span class="sd">    return_lower_triangular : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the coefficients of the fit.</span>
<span class="sd">    return_leverages : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the fitting leverages.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eigvals : array (..., 3)</span>
<span class="sd">        Eigenvalues from eigen decomposition of the tensor.</span>
<span class="sd">    eigvecs : array (..., 3, 3)</span>
<span class="sd">        Associated eigenvectors from eigen decomposition of the tensor.</span>
<span class="sd">        Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with</span>
<span class="sd">        eigvals[j])</span>
<span class="sd">    leverages : array (g)</span>
<span class="sd">        Leverages of the fitting problem (if return_leverages is True)</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    WLS_fit_tensor, decompose_tensor, design_matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. math::</span>

<span class="sd">        y = \mathrm{data} \\</span>
<span class="sd">        X = \mathrm{design matrix} \\</span>

<span class="sd">        \hat{\beta}_\mathrm{OLS} = (X^T X)^{-1} X^T y</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_leverages</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fit_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;...ij,...j&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">leverages</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">)</span>
        <span class="n">fit_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ij,...j&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">leverages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ji-&gt;i&quot;</span><span class="p">,</span> <span class="n">design_matrix</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">leverages</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">leverages</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;leverages&quot;</span><span class="p">:</span> <span class="n">leverages</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">return_lower_triangular</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fit_result</span><span class="p">,</span> <span class="n">leverages</span>

    <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">eig_from_lo_tri</span><span class="p">(</span><span class="n">fit_result</span><span class="p">,</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">tol</span> <span class="o">/</span> <span class="o">-</span><span class="n">design_matrix</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fit_result</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">),</span> <span class="n">leverages</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eig_from_lo_tri</span><span class="p">(</span>
            <span class="n">fit_result</span><span class="p">,</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">tol</span> <span class="o">/</span> <span class="o">-</span><span class="n">design_matrix</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="p">),</span> <span class="n">leverages</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ols_fit_matrix</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to calculate the ordinary least squares (OLS)</span>
<span class="sd">    fit as a matrix multiplication. Mainly used to calculate WLS weights. Can</span>
<span class="sd">    be used to calculate regression coefficients in OLS but not recommended.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    wls_fit_tensor, ols_fit_tensor</span>

<span class="sd">    Examples</span>
<span class="sd">    ---------</span>
<span class="sd">    ols_fit = _ols_fit_matrix(design_mat)</span>
<span class="sd">    ols_data = np.dot(ols_fit, data)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_NllsHelper</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Class with member functions to return nlls error and derivative.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">err_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Error function for the non-linear least-squares fit of the tensor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : array (3,3)</span>
<span class="sd">            The 3-by-3 tensor matrix</span>

<span class="sd">        design_matrix : array</span>
<span class="sd">            The design matrix</span>

<span class="sd">        data : array</span>
<span class="sd">            The voxel signal in all gradient directions</span>

<span class="sd">        weights : array ([X, Y, Z, ...], g), optional</span>
<span class="sd">            Weights to apply for fitting. These weights must correspond to the</span>
<span class="sd">            squared residuals such that $S = \sum_i w_i r_i^2$.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is the predicted signal given the params:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">tensor</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>  <span class="c1"># cache the results</span>

        <span class="c1"># Compute the residuals</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">y</span>

        <span class="c1"># Set weights</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_w</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># cache weights for the *non-squared* residuals</span>
            <span class="c1"># And we return the SSE:</span>
            <span class="k">return</span> <span class="n">residuals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return the weighted residuals:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_w</span> <span class="o">*</span> <span class="n">residuals</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                    <span class="c1"># cache the weights for the *non-squared* residuals</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_w</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">jacobian_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The Jacobian is the first derivative of the error function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : array (3,3)</span>
<span class="sd">            The 3-by-3 tensor matrix</span>

<span class="sd">        design_matrix : array</span>
<span class="sd">            The design matrix</span>

<span class="sd">        data : array</span>
<span class="sd">            The voxel signal in all gradient directions</span>

<span class="sd">        weights : array ([X, Y, Z, ...], g), optional</span>
<span class="sd">            Weights to apply for fitting. These weights must correspond to the</span>
<span class="sd">            squared residuals such that $S = \sum_i w_i r_i^2$.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This Jacobian correctly accounts for weights on the squared residuals</span>
<span class="sd">        if provided.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. footbibliography::</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># minus sign, because derivative of residuals = data - y</span>
        <span class="c1"># sqrt(w) because w corresponds to the squared residuals</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">design_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">design_matrix</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt_w</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_decompose_tensor_nan</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">tensor_alternative</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function that expands the function decompose_tensor to deal</span>
<span class="sd">    with tensor with nan elements.</span>

<span class="sd">    Computes tensor eigen decomposition to calculate eigenvalues and</span>
<span class="sd">    eigenvectors (Basser et al., 1994a). Some fit approaches can produce nan</span>
<span class="sd">    tensor elements in background voxels (particularly non-linear approaches).</span>
<span class="sd">    This function avoids the eigen decomposition errors of nan tensor elements</span>
<span class="sd">    by replacing tensor with nan elements by a given alternative tensor</span>
<span class="sd">    estimate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : array (3, 3)</span>
<span class="sd">        Hermitian matrix representing a diffusion tensor.</span>
<span class="sd">    tensor_alternative : array (3, 3)</span>
<span class="sd">        Hermitian matrix representing a diffusion tensor obtain from an</span>
<span class="sd">        approach that does not produce nan tensor elements</span>
<span class="sd">    min_diffusivity : float, optional</span>
<span class="sd">        Because negative eigenvalues are not physical and small eigenvalues,</span>
<span class="sd">        much smaller than the diffusion weighting, cause quite a lot of noise</span>
<span class="sd">        in metrics such as fa, diffusivity values smaller than</span>
<span class="sd">        `min_diffusivity` are replaced with `min_diffusivity`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eigvals : array (3)</span>
<span class="sd">        Eigenvalues from eigen decomposition of the tensor. Negative</span>
<span class="sd">        eigenvalues are replaced by zero. Sorted from largest to smallest.</span>
<span class="sd">    eigvecs : array (3, 3)</span>
<span class="sd">        Associated eigenvectors from eigen decomposition of the tensor.</span>
<span class="sd">        Eigenvectors are columnar (e.g. eigvecs[..., :, j] is associated with</span>
<span class="sd">        eigvals[..., j])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">decompose_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">[:</span><span class="mi">6</span><span class="p">],</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">min_diffusivity</span><span class="p">)</span>

    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">decompose_tensor</span><span class="p">(</span>
            <span class="n">tensor_alternative</span><span class="p">[:</span><span class="mi">6</span><span class="p">],</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">min_diffusivity</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">nlls_fit_tensor</span><span class="p">(</span>
    <span class="n">design_matrix</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">fail_is_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_leverages</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">init_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit the cumulant expansion params (e.g. DTI, DKI) using non-linear</span>
<span class="sd">    least-squares.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    design_matrix : array (g, Npar)</span>
<span class="sd">        Design matrix holding the covariants used to solve for the regression</span>
<span class="sd">        coefficients. First six parameters of design matrix should correspond</span>
<span class="sd">        to the six unique diffusion tensor elements in the lower triangular</span>
<span class="sd">        order (Dxx, Dxy, Dyy, Dxz, Dyz, Dzz), while last parameter to -log(S0)</span>

<span class="sd">    data : array ([X, Y, Z, ...], g)</span>
<span class="sd">        Data or response variables holding the data. Note that the last</span>
<span class="sd">        dimension should contain the data. It makes no copies of data.</span>

<span class="sd">    weights : array ([X, Y, Z, ...], g), optional</span>
<span class="sd">        Weights to apply for fitting. These weights must correspond to the</span>
<span class="sd">        squared residuals such that $S = \sum_i w_i r_i^2$.</span>

<span class="sd">    jac : bool, optional</span>
<span class="sd">        Use the Jacobian?</span>

<span class="sd">    return_S0_hat : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the S0 values for the fit.</span>

<span class="sd">    fail_is_nan : bool, optional</span>
<span class="sd">        Boolean to set failed NL fitting to NaN (True) or LS (False, default).</span>

<span class="sd">    return_lower_triangular : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the coefficients of the fit.</span>

<span class="sd">    return_leverages : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the fitting leverages.</span>

<span class="sd">    init_params : array ([X, Y, Z, ...], Npar), optional</span>
<span class="sd">        Parameters in lower triangular form as initial optimization guess.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nlls_params: the eigen-values and eigen-vectors of the tensor in each</span>
<span class="sd">        voxel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>

    <span class="c1"># Detect number of parameters to estimate from design_matrix length plus</span>
    <span class="c1"># 5 due to diffusion tensor conversion to eigenvalue and eigenvectors</span>
    <span class="n">npa</span> <span class="o">=</span> <span class="n">design_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span>

    <span class="c1"># Detect if number of parameters corresponds to dti</span>
    <span class="n">dti</span> <span class="o">=</span> <span class="n">npa</span> <span class="o">==</span> <span class="mi">12</span>

    <span class="c1"># Flatten for the iteration over voxels:</span>
    <span class="n">flat_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">init_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use the OLS method parameters as the starting point for nlls</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">ols_fit_tensor</span><span class="p">(</span>
            <span class="n">design_matrix</span><span class="p">,</span>
            <span class="n">flat_data</span><span class="p">,</span>
            <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">return_leverages</span><span class="o">=</span><span class="n">return_leverages</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">extra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leverages</span> <span class="o">=</span> <span class="n">extra</span><span class="p">[</span><span class="s2">&quot;leverages&quot;</span><span class="p">]</span>

        <span class="c1"># Flatten for the iteration over voxels:</span>
        <span class="n">ols_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Replace starting guess for opt (usually ols_params) with init_params</span>
        <span class="n">ols_params</span> <span class="o">=</span> <span class="n">init_params</span>

    <span class="c1"># Initialize parameter matrix</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">flat_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">npa</span><span class="p">))</span>

    <span class="c1"># Initialize parameter matrix for storing flattened parameters</span>
    <span class="n">flat_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">ols_params</span><span class="p">)</span>

    <span class="c1"># For warnings</span>
    <span class="n">resort_to_OLS</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Instance of _NllsHelper, need for nlls error func and jacobian</span>
    <span class="n">nlls</span> <span class="o">=</span> <span class="n">_NllsHelper</span><span class="p">()</span>
    <span class="n">err_func</span> <span class="o">=</span> <span class="n">nlls</span><span class="o">.</span><span class="n">err_func</span>
    <span class="n">jac_func</span> <span class="o">=</span> <span class="n">nlls</span><span class="o">.</span><span class="n">jacobian_func</span> <span class="k">if</span> <span class="n">jac</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
        <span class="n">model_S0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">flat_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">vox</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">flat_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flat_data</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The data in this voxel contains only zeros&quot;</span><span class="p">)</span>

        <span class="n">start_params</span> <span class="o">=</span> <span class="n">ols_params</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span>

        <span class="n">weights_vox</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Do the optimization in this voxel:</span>
            <span class="n">this_param</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
                <span class="n">err_func</span><span class="p">,</span>
                <span class="n">start_params</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">[</span><span class="n">vox</span><span class="p">],</span> <span class="n">weights_vox</span><span class="p">),</span>
                <span class="n">Dfun</span><span class="o">=</span><span class="n">jac_func</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">flat_params</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_param</span>

            <span class="c1"># Convert diffusion tensor parameters to the evals and the evecs:</span>
            <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">decompose_tensor</span><span class="p">(</span>
                <span class="n">from_lower_triangular</span><span class="p">(</span><span class="n">this_param</span><span class="p">[:</span><span class="mi">6</span><span class="p">]),</span>
                <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">tol</span> <span class="o">/</span> <span class="o">-</span><span class="n">design_matrix</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span>
            <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># If leastsq failed to converge and produced nans, we&#39;ll resort to the</span>
        <span class="c1"># OLS solution in this voxel:</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">resort_to_OLS</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">this_param</span> <span class="o">=</span> <span class="n">start_params</span>

            <span class="n">flat_params</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_param</span>  <span class="c1"># NOTE: ignores fail_is_nan</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">fail_is_nan</span><span class="p">:</span>
                <span class="c1"># Convert diffusion tensor parameters to evals and evecs</span>
                <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">decompose_tensor</span><span class="p">(</span>
                    <span class="n">from_lower_triangular</span><span class="p">(</span><span class="n">this_param</span><span class="p">[:</span><span class="mi">6</span><span class="p">]),</span>
                    <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">tol</span> <span class="o">/</span> <span class="o">-</span><span class="n">design_matrix</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                <span class="p">)</span>
                <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span>
                <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Set NaN values</span>
                <span class="n">this_param</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># so that S0_hat is NaN</span>
                <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
            <span class="n">model_S0</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">this_param</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dti</span><span class="p">:</span>
            <span class="n">md2</span> <span class="o">=</span> <span class="n">evals</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="mi">12</span><span class="p">:]</span> <span class="o">=</span> <span class="n">this_param</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">md2</span>

    <span class="k">if</span> <span class="n">resort_to_OLS</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">ols_resort_msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_leverages</span><span class="p">:</span>
        <span class="n">leverages</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;leverages&quot;</span><span class="p">:</span> <span class="n">leverages</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">leverages</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">return_lower_triangular</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flat_params</span><span class="p">,</span> <span class="n">leverages</span>

    <span class="n">params</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">npa</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
        <span class="n">model_S0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">params</span><span class="p">,</span> <span class="n">model_S0</span><span class="p">],</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="kc">None</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">restore_fit_tensor</span><span class="p">(</span>
    <span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fail_is_nan</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a robust tensor fit using the RESTORE algorithm.</span>

<span class="sd">    Note that the RESTORE algorithm defined in :footcite:p:`Chang2005` does not define</span>
<span class="sd">    Geman–McClure M-estimator weights as claimed (instead, Cauchy M-estimator</span>
<span class="sd">    weights are defined), but this function does define correct Geman–McClure</span>
<span class="sd">    M-estimator weights.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    design_matrix : array of shape (g, 7)</span>
<span class="sd">        Design matrix holding the covariants used to solve for the regression</span>
<span class="sd">        coefficients.</span>
<span class="sd">    data : array of shape ([X, Y, Z, n_directions], g)</span>
<span class="sd">        Data or response variables holding the data. Note that the last</span>
<span class="sd">        dimension should contain the data. It makes no copies of data.</span>
<span class="sd">    sigma : float, optional</span>
<span class="sd">        An estimate of the variance. :footcite:p:`Chang2005` recommend to use</span>
<span class="sd">        1.5267 * std(background_noise), where background_noise is estimated</span>
<span class="sd">        from some part of the image known to contain no signal (only noise).</span>
<span class="sd">        If not provided, will be estimated per voxel as:</span>
<span class="sd">        sigma = 1.4826 * sqrt(N / (N - p)) * MAD(residuals)</span>
<span class="sd">        as in :footcite:p:`Chang2012` but with the additional correction factor</span>
<span class="sd">        1.4826 required to link standard deviation to MAD.</span>
<span class="sd">    jac : bool, optional</span>
<span class="sd">        Whether to use the Jacobian of the tensor to speed the non-linear</span>
<span class="sd">        optimization procedure used to fit the tensor parameters (see also</span>
<span class="sd">        :func:`nlls_fit_tensor`).</span>
<span class="sd">    return_S0_hat : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the S0 values for the fit.</span>
<span class="sd">    fail_is_nan : bool, optional</span>
<span class="sd">        Boolean to set failed NL fitting to NaN (True) or LS (False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    restore_params : an estimate of the tensor parameters in each voxel.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Detect number of parameters to estimate from design_matrix length plus</span>
    <span class="c1"># 5 due to diffusion tensor conversion to eigenvalue and eigenvectors</span>
    <span class="n">npa</span> <span class="o">=</span> <span class="n">design_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span>

    <span class="c1"># Detect if number of parameters corresponds to dti</span>
    <span class="n">dti</span> <span class="o">=</span> <span class="n">npa</span> <span class="o">==</span> <span class="mi">12</span>

    <span class="c1"># define some constants</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">design_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.4826</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

    <span class="c1"># Flatten for the iteration over voxels:</span>
    <span class="n">flat_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># calculate OLS solution</span>
    <span class="n">D</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ols_fit_tensor</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">,</span> <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Flatten for the iteration over voxels:</span>
    <span class="n">ols_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Initialize parameter matrix</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">flat_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">npa</span><span class="p">))</span>

    <span class="c1"># For storing whether image is used in final fit for each voxel</span>
    <span class="n">robust</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">flat_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># For warnings</span>
    <span class="n">resort_to_OLS</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Instance of _NllsHelper, need for nlls error func and jacobian</span>
    <span class="n">nlls</span> <span class="o">=</span> <span class="n">_NllsHelper</span><span class="p">()</span>
    <span class="n">err_func</span> <span class="o">=</span> <span class="n">nlls</span><span class="o">.</span><span class="n">err_func</span>
    <span class="n">jac_func</span> <span class="o">=</span> <span class="n">nlls</span><span class="o">.</span><span class="n">jacobian_func</span> <span class="k">if</span> <span class="n">jac</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
        <span class="n">model_S0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">flat_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">vox</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">flat_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flat_data</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The data in this voxel contains only zeros&quot;</span><span class="p">)</span>

        <span class="n">start_params</span> <span class="o">=</span> <span class="n">ols_params</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Do unweighted nlls in this voxel:</span>
            <span class="n">this_param</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
                <span class="n">err_func</span><span class="p">,</span>
                <span class="n">start_params</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">[</span><span class="n">vox</span><span class="p">]),</span>
                <span class="n">Dfun</span><span class="o">=</span><span class="n">jac_func</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Get the residuals:</span>
            <span class="n">pred_sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">this_param</span><span class="p">))</span>
            <span class="n">residuals</span> <span class="o">=</span> <span class="n">flat_data</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">-</span> <span class="n">pred_sig</span>

            <span class="c1"># estimate or set sigma</span>
            <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">sigma</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">residuals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">residuals</span><span class="p">)))</span>

            <span class="c1"># If any of the residuals are outliers (using 3 sigma as a</span>
            <span class="c1"># criterion following Chang et al., e.g page 1089):</span>
            <span class="n">test_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>

            <span class="c1"># test for doing robust reweighting</span>
            <span class="k">if</span> <span class="n">test_sigma</span><span class="p">:</span>
                <span class="n">rdx</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">rdx</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># NOTE: capped at 10 iterations</span>
                    <span class="c1"># GM weights (original Restore paper used Cauchy weights)</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">residuals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">residuals</span><span class="p">)))</span>
                    <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">residuals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="n">gmm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                        <span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                        <span class="n">denominator</span><span class="p">,</span>
                        <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">denominator</span><span class="p">),</span>
                        <span class="n">where</span><span class="o">=</span><span class="n">denominator</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># Do nlls with GMM-weighting:</span>
                    <span class="n">this_param</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
                        <span class="n">err_func</span><span class="p">,</span>
                        <span class="n">start_params</span><span class="p">,</span>
                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">[</span><span class="n">vox</span><span class="p">],</span> <span class="n">gmm</span><span class="p">),</span>
                        <span class="n">Dfun</span><span class="o">=</span><span class="n">jac_func</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># Recalculate residuals given gmm fit</span>
                    <span class="n">pred_sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">this_param</span><span class="p">))</span>
                    <span class="n">residuals</span> <span class="o">=</span> <span class="n">flat_data</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">-</span> <span class="n">pred_sig</span>
                    <span class="n">perc</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="mi">100</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">this_param</span> <span class="o">-</span> <span class="n">start_params</span><span class="p">)</span>
                        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">this_param</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">start_params</span> <span class="o">=</span> <span class="n">this_param</span>
                    <span class="k">if</span> <span class="n">perc</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">rdx</span> <span class="o">=</span> <span class="n">rdx</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">C</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                    <span class="c1"># If you still have outliers, refit without those outliers:</span>
                    <span class="n">non_outlier_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">cond</span><span class="p">))</span>
                    <span class="n">clean_design</span> <span class="o">=</span> <span class="n">design_matrix</span><span class="p">[</span><span class="n">non_outlier_idx</span><span class="p">]</span>
                    <span class="n">clean_data</span> <span class="o">=</span> <span class="n">flat_data</span><span class="p">[</span><span class="n">vox</span><span class="p">][</span><span class="n">non_outlier_idx</span><span class="p">]</span>
                    <span class="n">robust</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>

                    <span class="c1"># recalculate OLS solution with clean data</span>
                    <span class="n">new_start</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ols_fit_tensor</span><span class="p">(</span>
                        <span class="n">clean_design</span><span class="p">,</span> <span class="n">clean_data</span><span class="p">,</span> <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

                    <span class="n">this_param</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
                        <span class="n">err_func</span><span class="p">,</span>
                        <span class="n">new_start</span><span class="p">,</span>
                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">clean_design</span><span class="p">,</span> <span class="n">clean_data</span><span class="p">),</span>
                        <span class="n">Dfun</span><span class="o">=</span><span class="n">jac_func</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># Convert diffusion tensor parameters to the evals and the evecs:</span>
            <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">decompose_tensor</span><span class="p">(</span><span class="n">from_lower_triangular</span><span class="p">(</span><span class="n">this_param</span><span class="p">[:</span><span class="mi">6</span><span class="p">]))</span>
            <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span>
            <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># If leastsq failed to converge and produced nans, we&#39;ll resort to the</span>
        <span class="c1"># OLS solution in this voxel:</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">resort_to_OLS</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">this_param</span> <span class="o">=</span> <span class="n">start_params</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">fail_is_nan</span><span class="p">:</span>
                <span class="c1"># Convert diffusion tensor parameters to evals and evecs:</span>
                <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">decompose_tensor</span><span class="p">(</span><span class="n">from_lower_triangular</span><span class="p">(</span><span class="n">this_param</span><span class="p">[:</span><span class="mi">6</span><span class="p">]))</span>
                <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span>
                <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Set NaN values</span>
                <span class="n">this_param</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># so that S0_hat is NaN</span>
                <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
            <span class="n">model_S0</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">this_param</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dti</span><span class="p">:</span>
            <span class="n">md2</span> <span class="o">=</span> <span class="n">evals</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">params</span><span class="p">[</span><span class="n">vox</span><span class="p">,</span> <span class="mi">12</span><span class="p">:]</span> <span class="o">=</span> <span class="n">this_param</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">md2</span>

    <span class="k">if</span> <span class="n">resort_to_OLS</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">ols_resort_msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">params</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">npa</span><span class="p">,)</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;robust&quot;</span><span class="p">:</span> <span class="n">robust</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
        <span class="n">model_S0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">params</span><span class="p">,</span> <span class="n">model_S0</span><span class="p">],</span> <span class="n">extra</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">extra</span>


<span class="k">def</span><span class="w"> </span><span class="nf">iterative_fit_tensor</span><span class="p">(</span>
    <span class="n">design_matrix</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">fit_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_iter</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">weights_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iteratively Reweighted fitting for the DTI/DKI model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    design_matrix : ndarray of shape (g, ...)</span>
<span class="sd">        Design matrix holding the covariants used to solve for the regression</span>
<span class="sd">        coefficients.</span>
<span class="sd">    data : ndarray of shape ([X, Y, Z, n_directions], g)</span>
<span class="sd">        Data or response variables holding the data. Note that the last</span>
<span class="sd">        dimension should contain the data. It makes no copies of data.</span>
<span class="sd">    jac : bool, optional</span>
<span class="sd">        Use the Jacobian for NLLS fitting (does nothing for WLS fitting).</span>
<span class="sd">    return_S0_hat : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the S0 values for the fit.</span>
<span class="sd">    fit_type : str, optional</span>
<span class="sd">        Whether to use NLLS or WLS fitting scheme.</span>
<span class="sd">    num_iter : int, optional</span>
<span class="sd">        Number of times to iterate.</span>
<span class="sd">    weights_method : callable, optional</span>
<span class="sd">        A function with args and returns as follows::</span>

<span class="sd">            (weights, robust) = weights_method(data, pred_sig, design_matrix,</span>
<span class="sd">                                               leverages, idx, num_iter, robust)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Take care to supply an appropriate weights_method for the fit_type.</span>
<span class="sd">    It is possible to use NLLS fitting with weights designed for WLS fitting,</span>
<span class="sd">    but this is a user error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>

    <span class="k">if</span> <span class="n">fit_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fit_type must be provided&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weights_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights_method must be provided&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_iter</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># otherwise, weights_method will not be utilized</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_iter must be 2+&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fit_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;WLS&quot;</span><span class="p">,</span> <span class="s2">&quot;NLLS&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fit_type must be &#39;WLS&#39; or &#39;NLLS&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Detect number of parameters to estimate from design_matrix length plus</span>
    <span class="c1"># 5 due to diffusion tensor conversion to eigenvalue and eigenvectors</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">design_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fewer data points than parameters.&quot;</span><span class="p">)</span>

    <span class="c1"># Detect if number of parameters corresponds to dti</span>
    <span class="n">npa</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">5</span>
    <span class="n">dti</span> <span class="o">=</span> <span class="n">npa</span> <span class="o">==</span> <span class="mi">12</span>

    <span class="n">w</span><span class="p">,</span> <span class="n">robust</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>  <span class="c1"># w = None means wls_fit_tensor uses WLS weights</span>
    <span class="n">D</span><span class="p">,</span> <span class="n">extra</span><span class="p">,</span> <span class="n">leverages</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>  <span class="c1"># initialize, for clarity</span>
    <span class="n">TDX</span> <span class="o">=</span> <span class="n">num_iter</span>
    <span class="k">for</span> <span class="n">rdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TDX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rdx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log_pred_sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pred_sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_pred_sig</span><span class="p">)</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">robust</span> <span class="o">=</span> <span class="n">weights_method</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">pred_sig</span><span class="p">,</span> <span class="n">design_matrix</span><span class="p">,</span> <span class="n">leverages</span><span class="p">,</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">TDX</span><span class="p">,</span> <span class="n">robust</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;WLS&quot;</span><span class="p">:</span>
            <span class="n">D</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">wls_fit_tensor</span><span class="p">(</span>
                <span class="n">design_matrix</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_leverages</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">leverages</span> <span class="o">=</span> <span class="n">extra</span><span class="p">[</span><span class="s2">&quot;leverages&quot;</span><span class="p">]</span>  <span class="c1"># for WLS, update leverages</span>

        <span class="k">if</span> <span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;NLLS&quot;</span><span class="p">:</span>
            <span class="n">D</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">nlls_fit_tensor</span><span class="p">(</span>
                <span class="n">design_matrix</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                <span class="n">return_lower_triangular</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_leverages</span><span class="o">=</span><span class="p">(</span><span class="n">rdx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span>
                <span class="n">init_params</span><span class="o">=</span><span class="n">D</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">rdx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># for NLLS, leverages from OLS, so they never change</span>
                <span class="n">leverages</span> <span class="o">=</span> <span class="n">extra</span><span class="p">[</span><span class="s2">&quot;leverages&quot;</span><span class="p">]</span>

    <span class="c1"># Convert diffusion tensor parameters to the evals and the evecs:</span>
    <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">decompose_tensor</span><span class="p">(</span>
        <span class="n">from_lower_triangular</span><span class="p">(</span><span class="n">D</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]),</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">tol</span> <span class="o">/</span> <span class="o">-</span><span class="n">design_matrix</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">npa</span><span class="p">,)))</span>
    <span class="n">params</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span>
    <span class="n">params</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

    <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
        <span class="n">model_S0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">D</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dti</span><span class="p">:</span>
        <span class="n">md2</span> <span class="o">=</span> <span class="n">evals</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># NOTE: changed from axis=0</span>
        <span class="n">params</span><span class="p">[:,</span> <span class="mi">12</span><span class="p">:]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">md2</span>

    <span class="n">extra</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;robust&quot;</span><span class="p">:</span> <span class="n">robust</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">return_S0_hat</span><span class="p">:</span>
        <span class="n">model_S0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">params</span><span class="p">,</span> <span class="n">model_S0</span><span class="p">],</span> <span class="n">extra</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">extra</span>


<span class="k">def</span><span class="w"> </span><span class="nf">robust_fit_tensor_wls</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_iter</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iteratively Reweighted fitting for WLS for the DTI/DKI model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    design_matrix : ndarray of shape (g, ...)</span>
<span class="sd">        Design matrix holding the covariants used to solve for the regression</span>
<span class="sd">        coefficients.</span>
<span class="sd">    data : ndarray of shape ([X, Y, Z, n_directions], g)</span>
<span class="sd">        Data or response variables holding the data. Note that the last</span>
<span class="sd">        dimension should contain the data. It makes no copies of data.</span>
<span class="sd">    return_S0_hat : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the S0 values for the fit.</span>
<span class="sd">    num_iter : int, optional</span>
<span class="sd">        Number of times to iterate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a convenience function that does::</span>

<span class="sd">        iterative_fit_tensor(*args, **kwargs, fit_type=&quot;WLS&quot;,</span>
<span class="sd">                             weights_method=weights_method_wls)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">iterative_fit_tensor</span><span class="p">(</span>
        <span class="n">design_matrix</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">return_S0_hat</span><span class="o">=</span><span class="n">return_S0_hat</span><span class="p">,</span>
        <span class="n">fit_type</span><span class="o">=</span><span class="s2">&quot;WLS&quot;</span><span class="p">,</span>
        <span class="n">num_iter</span><span class="o">=</span><span class="n">num_iter</span><span class="p">,</span>
        <span class="n">weights_method</span><span class="o">=</span><span class="n">weights_method_wls_m_est</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">robust_fit_tensor_nlls</span><span class="p">(</span>
    <span class="n">design_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_S0_hat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_iter</span><span class="o">=</span><span class="mi">4</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iteratively Reweighted fitting for NLLS for the DTI/DKI model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    design_matrix : ndarray of shape (g, ...)</span>
<span class="sd">        Design matrix holding the covariants used to solve for the regression</span>
<span class="sd">        coefficients.</span>
<span class="sd">    data : ndarray of shape ([X, Y, Z, n_directions], g)</span>
<span class="sd">        Data or response variables holding the data. Note that the last</span>
<span class="sd">        dimension should contain the data. It makes no copies of data.</span>
<span class="sd">    jac : bool, optional</span>
<span class="sd">        Use the Jacobian?</span>
<span class="sd">    return_S0_hat : bool, optional</span>
<span class="sd">        Boolean to return (True) or not (False) the S0 values for the fit.</span>
<span class="sd">    num_iter : int, optional</span>
<span class="sd">        Number of times to iterate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a convenience function that does::</span>

<span class="sd">        iterative_fit_tensor(*args, **kwargs, fit_type=&quot;NLLS&quot;,</span>
<span class="sd">        weights_method=weights_method_nlls)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">iterative_fit_tensor</span><span class="p">(</span>
        <span class="n">design_matrix</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span>
        <span class="n">return_S0_hat</span><span class="o">=</span><span class="n">return_S0_hat</span><span class="p">,</span>
        <span class="n">fit_type</span><span class="o">=</span><span class="s2">&quot;NLLS&quot;</span><span class="p">,</span>
        <span class="n">num_iter</span><span class="o">=</span><span class="n">num_iter</span><span class="p">,</span>
        <span class="n">weights_method</span><span class="o">=</span><span class="n">weights_method_nlls_m_est</span><span class="p">,</span>
    <span class="p">)</span>


<span class="n">_lt_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">from_lower_triangular</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a tensor given the six unique tensor elements</span>

<span class="sd">    Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,</span>
<span class="sd">    Dyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are</span>
<span class="sd">    ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : array_like, (..., &gt;6)</span>
<span class="sd">        Unique elements of the tensors</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor : ndarray (..., 3, 3)</span>
<span class="sd">        3 by 3 tensors</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_lt_indices</span><span class="p">]</span>


<span class="n">_lt_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">_lt_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">lower_triangular</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">b0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the six lower triangular values of the tensor ordered as</span>
<span class="sd">    (Dxx, Dxy, Dyy, Dxz, Dyz, Dzz) and a dummy variable if b0 is not None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : array_like (..., 3, 3)</span>
<span class="sd">        a collection of 3, 3 diffusion tensors</span>
<span class="sd">    b0 : float, optional</span>
<span class="sd">        if b0 is not none log(b0) is returned as the dummy variable</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : ndarray</span>
<span class="sd">        If b0 is none, then the shape will be (..., 6) otherwise (..., 7)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Diffusion tensors should be (..., 3, 3)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_lt_rows</span><span class="p">,</span> <span class="n">_lt_cols</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">7</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tensor</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span>
        <span class="n">D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_lt_rows</span><span class="p">,</span> <span class="n">_lt_cols</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">D</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">decompose_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns eigenvalues and eigenvectors given a diffusion tensor</span>

<span class="sd">    Computes tensor eigen decomposition to calculate eigenvalues and</span>
<span class="sd">    eigenvectors (Basser et al., 1994a).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : array (..., 3, 3)</span>
<span class="sd">        Hermitian matrix representing a diffusion tensor.</span>
<span class="sd">    min_diffusivity : float, optional</span>
<span class="sd">        Because negative eigenvalues are not physical and small eigenvalues,</span>
<span class="sd">        much smaller than the diffusion weighting, cause quite a lot of noise</span>
<span class="sd">        in metrics such as fa, diffusivity values smaller than</span>
<span class="sd">        `min_diffusivity` are replaced with `min_diffusivity`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eigvals : array (..., 3)</span>
<span class="sd">        Eigenvalues from eigen decomposition of the tensor. Negative</span>
<span class="sd">        eigenvalues are replaced by zero. Sorted from largest to smallest.</span>
<span class="sd">    eigvecs : array (..., 3, 3)</span>
<span class="sd">        Associated eigenvectors from eigen decomposition of the tensor.</span>
<span class="sd">        Eigenvectors are columnar (e.g. eigvecs[..., :, j] is associated with</span>
<span class="sd">        eigvals[..., j])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># outputs multiplicity as well so need to unique</span>
    <span class="n">eigenvals</span><span class="p">,</span> <span class="n">eigenvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

    <span class="c1"># need to sort the eigenvalues and associated eigenvectors</span>
    <span class="k">if</span> <span class="n">eigenvals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># this is a lot faster when dealing with a single voxel</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">eigenvecs</span> <span class="o">=</span> <span class="n">eigenvecs</span><span class="p">[:,</span> <span class="n">order</span><span class="p">]</span>
        <span class="n">eigenvals</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># temporarily flatten eigenvals and eigenvecs to make sorting easier</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">eigenvals</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">eigenvecs</span> <span class="o">=</span> <span class="n">eigenvecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="n">size</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">eigenvecs</span> <span class="o">=</span> <span class="n">eigenvecs</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">order</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]]</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="n">size</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">eigenvals</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">order</span><span class="p">]</span>
        <span class="n">eigenvecs</span> <span class="o">=</span> <span class="n">eigenvecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">eigenvals</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
    <span class="n">eigenvals</span> <span class="o">=</span> <span class="n">eigenvals</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="n">min_diffusivity</span><span class="p">)</span>
    <span class="c1"># eigenvecs: each vector is columnar</span>

    <span class="k">return</span> <span class="n">eigenvals</span><span class="p">,</span> <span class="n">eigenvecs</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constructs design matrix for DTI weighted least squares or</span>
<span class="sd">    least squares fitting. (Basser et al., 1994a)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gtab : A GradientTable class instance</span>

<span class="sd">    dtype : str, optional</span>
<span class="sd">        Parameter to control the dtype of returned designed matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    design_matrix : array (g,7)</span>
<span class="sd">        Design matrix or B matrix assuming Gaussian distributed tensor model</span>
<span class="sd">        design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gtab</span><span class="o">.</span><span class="n">btens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">gtab</span><span class="o">.</span><span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">7</span><span class="p">))</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvals</span>  <span class="c1"># Bxx</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvals</span>  <span class="c1"># Bxy</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvals</span>  <span class="c1"># Byy</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvals</span>  <span class="c1"># Bxz</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvals</span>  <span class="c1"># Byz</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvecs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">gtab</span><span class="o">.</span><span class="n">bvals</span>  <span class="c1"># Bzz</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">gtab</span><span class="o">.</span><span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">gtab</span><span class="o">.</span><span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">7</span><span class="p">))</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">btens</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Bxx</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">btens</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># Bxy</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">btens</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Byy</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">btens</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># Bxz</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">btens</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># Byz</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtab</span><span class="o">.</span><span class="n">btens</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># Bzz</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">gtab</span><span class="o">.</span><span class="n">gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">B</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">quantize_evecs</span><span class="p">(</span><span class="n">evecs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">odf_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the closest orientation of an evenly distributed sphere</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    evecs : ndarray</span>
<span class="sd">        Eigenvectors.</span>
<span class="sd">    odf_vertices : ndarray, optional</span>
<span class="sd">        If None, then set vertices from symmetric362 sphere.  Otherwise use</span>
<span class="sd">        passed ndarray as vertices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    IN : ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_evecs</span> <span class="o">=</span> <span class="n">evecs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">odf_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">odf_vertices</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;symmetric362&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">tup</span> <span class="o">=</span> <span class="n">max_evecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mec</span> <span class="o">=</span> <span class="n">max_evecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tup</span><span class="p">)),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">IN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">odf_vertices</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mec</span><span class="p">])</span>
    <span class="n">IN</span> <span class="o">=</span> <span class="n">IN</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">IN</span>


<span class="nd">@warning_for_keywords</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">eig_from_lo_tri</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates tensor eigenvalues/eigenvectors from an array containing the</span>
<span class="sd">    lower diagonal form of the six unique tensor elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like (..., 6)</span>
<span class="sd">        diffusion tensors elements stored in lower triangular order</span>
<span class="sd">    min_diffusivity : float, optional</span>
<span class="sd">        See decompose_tensor()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dti_params : array (..., 12)</span>
<span class="sd">        Eigen-values and eigen-vectors of the same array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">decompose_tensor</span><span class="p">(</span>
        <span class="n">from_lower_triangular</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">min_diffusivity</span><span class="o">=</span><span class="n">min_diffusivity</span>
    <span class="p">)</span>
    <span class="n">dti_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">evecs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dti_params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">12</span><span class="p">,))</span>


<span class="n">common_fit_methods</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;WLS&quot;</span><span class="p">:</span> <span class="n">wls_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;WLLS&quot;</span><span class="p">:</span> <span class="n">wls_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;LS&quot;</span><span class="p">:</span> <span class="n">ols_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;LLS&quot;</span><span class="p">:</span> <span class="n">ols_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;OLS&quot;</span><span class="p">:</span> <span class="n">ols_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;OLLS&quot;</span><span class="p">:</span> <span class="n">ols_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;NLS&quot;</span><span class="p">:</span> <span class="n">nlls_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;NLLS&quot;</span><span class="p">:</span> <span class="n">nlls_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;RESTORE&quot;</span><span class="p">:</span> <span class="n">restore_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;IRLS&quot;</span><span class="p">:</span> <span class="n">iterative_fit_tensor</span><span class="p">,</span>
    <span class="s2">&quot;RWLS&quot;</span><span class="p">:</span> <span class="n">robust_fit_tensor_wls</span><span class="p">,</span>
    <span class="s2">&quot;RNLLS&quot;</span><span class="p">:</span> <span class="n">robust_fit_tensor_nlls</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, MICA Lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>